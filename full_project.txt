## Arquivo: src/domtech_forger/__init__.py
# Este arquivo pode ficar vazio. Ele serve para que o Python trate o diret√≥rio 'domtech_forger' como um pacote.

---
## Arquivo: src/domtech_forger/main.py

import os
import re
import subprocess
import argparse
from datetime import datetime

# --- CONFIGURA√á√ÉO ---
FILE_HEADER_PATTERN = re.compile(r'## Arquivo: (.*?)\n')
COMMIT_HEADER_PATTERN = re.compile(r'## Mensagem de Commit:\n')
# Lista de arquivos e diret√≥rios que n√£o devem ser sobrescritos se j√° existirem.
PROTECTED_PATHS = ['.env', 'PROMPT_TEMPLATE.md']

# Novas configura√ß√µes para o modo de consolida√ß√£o
# Padr√µes de diret√≥rios/arquivos a serem ignorados durante a travessia do diret√≥rio.
# Baseado em .gitignore e senso comum para projetos de desenvolvimento.
IGNORE_PATTERNS_FOR_CONSOLIDATION = [
    '.git', '__pycache__', 'venv', '.venv', 'env', 'dist', 'build', '.vscode', '.idea',
    '.DS_Store' # Ignora arquivos do macOS
]

# Nova lista de arquivos a serem exclu√≠dos especificamente quando o DomTech Forger
# est√° consolidando o seu pr√≥prio c√≥digo-fonte.
# Estes devem ser caminhos relativos *a partir da raiz do reposit√≥rio do DomTech Forger*.
FORGER_SELF_EXCLUDE_PATHS_FROM_CONSOLIDATION = [
    # 'src/domtech_forger/main.py',
    # 'src/domtech_forger/__init__.py'
    'full_project.txt'
    # Adicione outros arquivos do pr√≥prio Forger aqui se precisar que sejam ignorados
    # quando ele consolida o seu pr√≥prio c√≥digo. Ex: 'docs/development_notes.md'
]

def get_watermark(is_special_case=False):
    """Gera um carimbo de data/hora."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    if is_special_case:
        # Formato para arquivos sem extens√£o como LICENSE
        return f"\n\n# --- \n# Arquivo atualizado pelo DomTech Forger em {timestamp}\n"
    return f"# Este arquivo foi gerado/atualizado pelo DomTech Forger em {timestamp}\n\n"

def get_markdown_watermark():
    """Gera um carimbo de data/hora espec√≠fico para Markdown."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    return f"<!-- Este arquivo foi gerado/atualizado pelo DomTech Forger em {timestamp} -->\n\n"

def strip_watermark(content, relative_path):
    """Remove DomTech Forger watermarks do conte√∫do do arquivo."""
    # Padr√µes de watermark (precisam ser re-avaliados com base nos formatos gerados)
    python_like_watermark_pattern = re.compile(r"^# Este arquivo foi gerado/atualizado pelo DomTech Forger em \d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\n\n")
    markdown_watermark_pattern = re.compile(r"^<!-- Este arquivo foi gerado/atualizado pelo DomTech Forger em \d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2} -->\n\n")
    # Padr√£o para arquivos como LICENSE (watermark no final)
    special_case_watermark_pattern = re.compile(r"\n\n# --- \n# Arquivo atualizado pelo DomTech Forger em \d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\n$")

    _, file_extension = os.path.splitext(relative_path)

    if file_extension == '.md':
        content = re.sub(markdown_watermark_pattern, '', content, count=1)
    # Verifica se √© um caso especial (ex: LICENSE), a watermark √© no final do arquivo
    elif re.search(special_case_watermark_pattern, content):
        content = re.sub(special_case_watermark_pattern, '', content, count=1)
    else: # Padr√£o para .py, .gitignore, etc.
        content = re.sub(python_like_watermark_pattern, '', content, count=1)
    return content

def run_git_command(command, target_dir):
    """Executa um comando git dentro de um diret√≥rio alvo."""
    try:
        subprocess.run(command, check=True, capture_output=True, text=True, encoding='utf-8', cwd=target_dir)
        return True
    except subprocess.CalledProcessError as e:
        print(f"‚ùå Erro ao executar o comando git: {' '.join(command)} em '{target_dir}'")
        print(f"   Sa√≠da de erro: {e.stderr}")
        return False
    except FileNotFoundError:
        print("‚ùå Erro: O comando 'git' n√£o foi encontrado. Verifique se o Git est√° instalado e no seu PATH.")
        return False

def apply_updates(source_file, destination_dir, perform_commit):
    """
    L√™ o arquivo de c√≥digo-fonte consolidado, distribui o conte√∫do
    e, opcionalmente, faz o commit das altera√ß√µes no diret√≥rio de destino.
    """
    print(f"‚öôÔ∏è  Iniciando atualiza√ß√£o do projeto em '{destination_dir}'...")
    print(f"   Usando o arquivo de origem: '{source_file}'")

    try:
        with open(source_file, 'r', encoding='utf-8') as f:
            content = f.read()
    except FileNotFoundError:
        print(f"‚ùå Erro: O arquivo de origem '{source_file}' n√£o foi encontrado.")
        print("Por favor, verifique o caminho e tente novamente.")
        return

    blocks = content.split('\n---\n')
    files_created_or_updated = 0
    commit_message = None

    for block in blocks:
        if not block.strip():
            continue

        file_match = FILE_HEADER_PATTERN.search(block)
        commit_match = COMMIT_HEADER_PATTERN.search(block)

        if file_match:
            relative_path = file_match.group(1).strip()
            full_path = os.path.join(destination_dir, relative_path)
            # Conte√∫do do arquivo √© tudo ap√≥s o cabe√ßalho do arquivo
            # e antes de um poss√≠vel cabe√ßalho de commit ou o pr√≥ximo "---"
            code_content = block[file_match.end():].strip()

            if relative_path in PROTECTED_PATHS:
                if os.path.exists(full_path):
                    print(f"‚ö†Ô∏è  Arquivo protegido '{full_path}' j√° existe. Pulando para manter a vers√£o local.")
                    continue
                else:
                    print(f"‚ú®  Criando arquivo de exemplo para '{full_path}'.")

            try:
                directory = os.path.dirname(full_path)
                if directory:
                    os.makedirs(directory, exist_ok=True)

                # L√≥gica do Carimbo de Data/Hora
                _, file_extension = os.path.splitext(relative_path)

                if file_extension == '.md':
                    watermark = get_markdown_watermark()
                    final_content = watermark + code_content
                # Verifica se o arquivo n√£o tem extens√£o ou est√° na lista de protegidos para aplicar watermark especial (ex: LICENSE)
                elif not file_extension or relative_path in PROTECTED_PATHS:
                    # Para arquivos como LICENSE, a watermark deve ser adicionada ao final
                    watermark = get_watermark(is_special_case=True)
                    final_content = code_content + watermark
                else: # Padr√£o para .py, .gitignore, etc.
                    watermark = get_watermark()
                    final_content = watermark + code_content

                with open(full_path, 'w', encoding='utf-8') as f:
                    f.write(final_content)

                print(f"‚úîÔ∏è Arquivo '{full_path}' criado/atualizado com sucesso.")
                files_created_or_updated += 1
            except IOError as e:
                print(f"‚ùå Erro ao escrever o arquivo '{full_path}': {e}")

        elif commit_match:
            commit_message = block[commit_match.end():].strip()
            print("‚úîÔ∏è Mensagem de commit encontrada.")

    print(f"\nÔøΩÔøΩ Processo de arquivos conclu√≠do! {files_created_or_updated} arquivos foram atualizados.")

    if perform_commit and commit_message:
        print(f"\nüöÄ Iniciando processo de versionamento em '{destination_dir}'...")
        print("   Adicionando todos os arquivos ao stage...")
        if run_git_command(['git', 'add', '.'], destination_dir):
            print(f"   Fazendo commit com a mensagem:\n---IN√çCIO---\n{commit_message}\n---FIM---")
            if run_git_command(['git', 'commit', '-m', commit_message], destination_dir):
                print("‚úÖ Commit realizado com sucesso!")
    elif perform_commit and not commit_message:
        print("\n‚ö†Ô∏è O commit foi solicitado, mas nenhuma mensagem de commit foi encontrada no arquivo de origem.")
    else:
        print("\n‚ÑπÔ∏è  O commit autom√°tico n√£o foi solicitado. Processo finalizado.")

def consolidate_project(source_dir, output_file):
    """
    L√™ todos os arquivos de um diret√≥rio de projeto e gera um √∫nico arquivo
    seguindo o formato de entrada do DomTech Forger.
    """
    print(f"‚öôÔ∏è  Iniciando consolida√ß√£o do projeto de '{source_dir}'...")
    print(f"   Gerando arquivo de sa√≠da: '{output_file}'")

    consolidated_content_parts = []
    files_processed = 0

    # Determina o caminho absoluto da raiz do reposit√≥rio do DomTech Forger
    # Isso permite verificar se estamos consolidando o pr√≥prio forger.
    forger_root_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))
    is_self_consolidation = os.path.commonpath([os.path.abspath(source_dir), forger_root_path]) == forger_root_path


    for root, dirs, files in os.walk(source_dir, topdown=True):
        # Exclui diret√≥rios ignorados da travessia
        dirs[:] = [d for d in dirs if d not in IGNORE_PATTERNS_FOR_CONSOLIDATION and not d.startswith('.')] # Ignora tamb√©m diret√≥rios ocultos n√£o listados

        for file in files:
            # Ignora arquivos ocultos n√£o explicitamente gerenciados (ex: .DS_Store)
            if file.startswith('.') and file not in PROTECTED_PATHS:
                continue

            full_path = os.path.join(root, file)
            # Garante que o caminho relativo seja a partir do diret√≥rio de origem
            relative_path_from_source_dir = os.path.relpath(full_path, source_dir)

            # N√£o consolida o pr√≥prio arquivo de sa√≠da se estiver dentro do diret√≥rio de origem
            if os.path.abspath(full_path) == os.path.abspath(output_file):
                print(f"‚ö†Ô∏è  Pulando o arquivo de sa√≠da gerado: '{relative_path_from_source_dir}'")
                continue

            # NOVO: Verifica se √© um arquivo do pr√≥prio DomTech Forger e deve ser exclu√≠do.
            if is_self_consolidation:
                # Obt√©m o caminho relativo do arquivo a partir da raiz do DomTech Forger
                # para comparar com a lista FORGER_SELF_EXCLUDE_PATHS_FROM_CONSOLIDATION.
                relative_path_from_forger_root = os.path.relpath(full_path, forger_root_path)
                if relative_path_from_forger_root in FORGER_SELF_EXCLUDE_PATHS_FROM_CONSOLIDATION:
                    print(f"‚ö†Ô∏è  Pulando arquivo interno do DomTech Forger (configurado): '{relative_path_from_source_dir}'")
                    continue

            try:
                with open(full_path, 'r', encoding='utf-8') as f:
                    content = f.read()

                stripped_content = strip_watermark(content, relative_path_from_source_dir)

                # Adiciona cabe√ßalho do arquivo e conte√∫do
                consolidated_content_parts.append(f"## Arquivo: {relative_path_from_source_dir}\n") # Adiciona newline ap√≥s o cabe√ßalho
                consolidated_content_parts.append(stripped_content.strip()) # Adiciona conte√∫do limpo
                consolidated_content_parts.append("\n---") # Adiciona separador e uma nova linha para o pr√≥ximo bloco
                files_processed += 1
                print(f"‚úîÔ∏è Adicionado '{relative_path_from_source_dir}'")

            except UnicodeDecodeError:
                print(f"‚ö†Ô∏è  Pulando arquivo bin√°rio ou ileg√≠vel: '{relative_path_from_source_dir}'")
            except Exception as e:
                print(f"‚ùå Erro ao ler o arquivo '{full_path}': {e}")

    # Remove o √∫ltimo "\n---" se existir
    if consolidated_content_parts and consolidated_content_parts[-1] == "\n---":
        consolidated_content_parts.pop()

    if not consolidated_content_parts:
        print("‚ö†Ô∏è  Nenhum arquivo eleg√≠vel encontrado para consolida√ß√£o.")
        return

    try:
        # Junta todas as partes com uma nova linha para criar o conte√∫do final
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("\n".join(consolidated_content_parts))
        print(f"\nüéâ Consolida√ß√£o conclu√≠da! {files_processed} arquivos processados. Sa√≠da gravada em '{output_file}'.")
    except IOError as e:
        print(f"‚ùå Erro ao escrever o arquivo de sa√≠da '{output_file}': {e}")

def main():
    """Fun√ß√£o principal para analisar os argumentos e iniciar o script."""
    parser = argparse.ArgumentParser(description="DomTech Forger: Ferramenta para gerenciar arquivos de projeto com LLMs.")

    # Grupo mutuamente exclusivo para os modos de opera√ß√£o
    mode_group = parser.add_mutually_exclusive_group(required=True)
    mode_group.add_argument(
        '--apply',
        action='store_true',
        help="Modo de aplica√ß√£o: distribui c√≥digo de um arquivo de origem para um diret√≥rio de destino."
    )
    mode_group.add_argument(
        '--consolidate',
        action='store_true',
        help="Modo de consolida√ß√£o: l√™ um diret√≥rio de projeto e gera um √∫nico arquivo de sa√≠da."
    )

    # Argumentos para o modo 'apply'
    parser.add_argument(
        '--source-file',
        type=str,
        help="[Modo Apply] Caminho para o arquivo de texto com as atualiza√ß√µes."
    )
    parser.add_argument(
        '--destination',
        type=str,
        default='.',
        help="[Modo Apply] Caminho para o diret√≥rio do projeto alvo. Padr√£o: diret√≥rio atual."
    )
    parser.add_argument(
        '--commit',
        type=str,
        choices=['true', 'false'],
        default='true',
        help="[Modo Apply] Define se o script deve fazer o commit das altera√ß√µes. Padr√£o: true"
    )

    # Argumentos para o modo 'consolidate'
    parser.add_argument(
        '--source-directory',
        type=str,
        help="[Modo Consolidate] Caminho para o diret√≥rio do projeto a ser consolidado."
    )
    parser.add_argument(
        '--output-file',
        type=str,
        help="[Modo Consolidate] Caminho para o arquivo de sa√≠da consolidado."
    )

    args = parser.parse_args()

    if args.apply:
        if not args.source_file:
            parser.error("--source-file √© obrigat√≥rio para o modo --apply.")
        apply_updates(
            source_file=args.source_file,
            destination_dir=args.destination,
            perform_commit=(args.commit == 'true')
        )
    elif args.consolidate:
        if not args.source_directory or not args.output_file:
            parser.error("--source-directory e --output-file s√£o obrigat√≥rios para o modo --consolidate.")
        consolidate_project(
            source_dir=args.source_directory,
            output_file=args.output_file
        )

if __name__ == "__main__":
    main()

---
## Arquivo: .gitignore
# Ambientes virtuais
venv/
.venv/
env/

# Arquivos de cache do Python
__pycache__/
*.pyc

# Arquivos de IDE
.vscode/
.idea/

# Arquivos de depend√™ncias e build
dist/
build/
*.egg-info/

---
## Arquivo: LICENSE
MIT License

Copyright (c) 2025 Dom Tech Solutions

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

---
## Arquivo: PROMPT_TEMPLATE.md
# Prompt Template para Gera√ß√£o de C√≥digo Compat√≠vel com o DomTech Forger

Use o seguinte template ao instruir um Large Language Model (LLM) para gerar o c√≥digo-fonte de um projeto completo em um √∫nico bloco de texto. Isso garantir√° que a sa√≠da seja compat√≠vel com a ferramenta de automa√ß√£o `DomTech Forger`.

O **DomTech Forger** tamb√©m pode gerar este formato a partir de um projeto existente utilizando a funcionalidade `--consolidate`. Essa sa√≠da pode ser diretamente usada como contexto para seu LLM.

## Template do Prompt

"Por favor, gere a estrutura completa de arquivos para o projeto [NOME DO PROJETO]. A sa√≠da deve ser um √∫nico bloco de c√≥digo. Cada arquivo deve ser precedido por um cabe√ßalho no formato `## Arquivo: caminho/completo/do/arquivo.ext` e o conte√∫do de cada arquivo deve ser separado por uma linha contendo apenas `---`.

Se houver uma mensagem de commit sugerida, ela deve estar em seu pr√≥prio bloco, precedida por `## Mensagem de Commit:` e separada por `---`.

**Exemplo de Estrutura:**

Arquivo: src/main.py
print("Ol√°, Mundo!")

Arquivo: README.md
Meu Projeto
Este √© um projeto de exemplo.

Mensagem de Commit:
feat: cria estrutura inicial do projeto

Adiciona os arquivos main.py e README.md para a configura√ß√£o inicial do projeto.

"
---
## Arquivo: README.md
# DomTech Forger

**DomTech Forger** √© uma ferramenta de linha de comando em Python projetada para automatizar a cria√ß√£o e atualiza√ß√£o de projetos de software. Ele l√™ um √∫nico arquivo de texto contendo o c√≥digo-fonte de m√∫ltiplos arquivos e os distribui na estrutura de diret√≥rios correta, al√©m de, opcionalmente, fazer o commit das altera√ß√µes no Git.

Este projeto nasceu para acelerar o desenvolvimento iterativo, especialmente ao colaborar com Large Language Models (LLMs). √â uma ferramenta da **Dom Tech Solutions**.

## Funcionalidades

*   Cria automaticamente a estrutura de diret√≥rios em um diret√≥rio de destino especificado.
*   Distribui o c√≥digo-fonte para os arquivos corretos a partir de um √∫nico arquivo de origem (`--apply`).
*   **Consolida um projeto existente** em um √∫nico arquivo de texto, pronto para contextualizar LLMs (`--consolidate`).
*   **Adiciona um carimbo de data/hora** em cada arquivo modificado para controle de vers√£o.
*   **Protege arquivos sens√≠veis** e de configura√ß√£o (como `.env` e `PROMPT_TEMPLATE.md`) de serem sobrescritos.
*   Opcionalmente, faz o `git commit` das altera√ß√µes no reposit√≥rio de destino com uma mensagem extra√≠da do pr√≥prio arquivo de origem.

## Instala√ß√£o e Uso

1.  **Clone o reposit√≥rio do DomTech Forger:**
    ```sh
    git clone [https://github.com/DomTechSolutions/domtech-forger.git](https://github.com/DomTechSolutions/domtech-forger.git)
    ```

2.  **Crie um arquivo de atualiza√ß√£o** (ex: `politicamente_update.txt`) em qualquer lugar, seguindo o formato especificado em `PROMPT_TEMPLATE.md`.

3.  **Execute o script:**
    Execute o script `DomTech Forger`, especificando o modo de opera√ß√£o e os par√¢metros necess√°rios.

    *   **Modo de Aplica√ß√£o (`--apply`):** Para distribuir o c√≥digo de um arquivo de origem para um projeto alvo.
        *   **Para atualizar e fazer o commit (padr√£o):**
            ```sh
            python /caminho/para/domtech-forger/src/domtech_forger/main.py --apply --source-file /caminho/para/politicamente_update.txt --destination /caminho/para/seu/projeto/alvo
            ```
        *   **Se voc√™ estiver dentro da pasta do projeto alvo, pode simplificar:**
            ```sh
            python /caminho/para/domtech-forger/src/domtech_forger/main.py --apply --source-file /caminho/para/politicamente_update.txt --destination .
            ```
        *   **Para apenas atualizar os arquivos, sem fazer o commit:**
            ```sh
            python /caminho/para/domtech-forger/src/domtech_forger/main.py --apply --source-file /caminho/para/politicamente_update.txt --destination . --commit=false
            ```
    *   **Modo de Consolida√ß√£o (`--consolidate`):** Para ler um diret√≥rio de projeto e gerar um √∫nico arquivo de sa√≠da.
        *   **Exemplo de uso:**
            ```sh
            python /caminho/para/domtech-forger/src/domtech_forger/main.py --consolidate --source-directory /caminho/para/seu/projeto/alvo --output-file /caminho/para/arquivo_consolidado.txt
            ```
        *   **Se voc√™ estiver dentro do diret√≥rio do projeto que deseja consolidar:**
            ```sh
            python /caminho/para/domtech-forger/src/domtech_forger/main.py --consolidate --source-directory . --output-file ./meu_projeto_consolidado.txt
            ```
    *Obs: Uma forma mais avan√ßada seria adicionar a pasta do `domtech-forger` ao seu `PATH` do sistema para poder cham√°-lo de qualquer lugar.*

## Licen√ßa

Este projeto √© licenciado sob a Licen√ßa MIT. Veja o arquivo `LICENSE` para mais detalhes.

---
## Mensagem de Commit:
feat: Implementa funcionalidade de consolida√ß√£o de projeto e atualiza documenta√ß√£o

Adiciona um novo modo `--consolidate` para o DomTech Forger, permitindo que o projeto leia um diret√≥rio de software existente e gere um arquivo √∫nico formatado para ser usado como entrada em LLMs.

Esta funcionalidade inclui:
- Travessia recursiva de diret√≥rios.
- Filtragem de arquivos e diret√≥rios irrelevantes (baseado em `.gitignore` e padr√µes comuns).
- Remo√ß√£o de watermarks do pr√≥prio Forger para um contexto limpo.
- Estrutura√ß√£o da sa√≠da no formato especificado.

Al√©m disso, foram atualizados o `README.md` para documentar o novo modo de uso e o `PROMPT_TEMPLATE.md` para destacar a utilidade da sa√≠da consolidada como insumo para modelos de linguagem. A l√≥gica de exclus√£o de arquivos internos do Forger foi refatorada para ser baseada em um array configur√°vel.