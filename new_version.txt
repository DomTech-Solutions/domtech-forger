# PROJETO: domtech-forger/

A estrutura de pastas profissional para a sua ferramenta.

domtech-forger/
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ PROMPT_TEMPLATE.md
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ src/
    ‚îî‚îÄ‚îÄ domtech_forger/
        ‚îú‚îÄ‚îÄ __init__.py
        ‚îî‚îÄ‚îÄ main.py


A seguir, o conte√∫do completo de cada arquivo.

---
## Arquivo: .gitignore

# Ambientes virtuais
venv/
.venv/
env/

# Arquivos de cache do Python
__pycache__/
*.pyc

# Arquivos de IDE
.vscode/
.idea/

# Arquivos de depend√™ncias e build
dist/
build/
*.egg-info/

---
## Arquivo: LICENSE

MIT License

Copyright (c) 2025 Dom Tech Solutions

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

---
## Arquivo: PROMPT_TEMPLATE.md

# Prompt Template para Gera√ß√£o de C√≥digo Compat√≠vel com o DomTech Forger

Use o seguinte template ao instruir um Large Language Model (LLM) para gerar o c√≥digo-fonte de um projeto completo em um √∫nico bloco de texto. Isso garantir√° que a sa√≠da seja compat√≠vel com a ferramenta de automa√ß√£o `DomTech Forger`.

## Template do Prompt

"Por favor, gere a estrutura completa de arquivos para o projeto [NOME DO PROJETO]. A sa√≠da deve ser um √∫nico bloco de c√≥digo. Cada arquivo deve ser precedido por um cabe√ßalho no formato `## Arquivo: caminho/completo/do/arquivo.ext` e o conte√∫do de cada arquivo deve ser separado por uma linha contendo apenas `---`.

Se houver uma mensagem de commit sugerida, ela deve estar em seu pr√≥prio bloco, precedida por `## Mensagem de Commit:` e separada por `---`.

**Exemplo de Estrutura:**

```
## Arquivo: src/main.py

print("Ol√°, Mundo!")

---
(separador)
---

## Arquivo: README.md

# Meu Projeto

Este √© um projeto de exemplo.

---
(separador)
---

## Mensagem de Commit:

feat: cria estrutura inicial do projeto

Adiciona os arquivos `main.py` e `README.md` para a configura√ß√£o inicial do projeto.
```"
---
## Arquivo: README.md

# DomTech Forger

**DomTech Forger** √© uma ferramenta de linha de comando em Python projetada para automatizar a cria√ß√£o e atualiza√ß√£o de projetos de software. Ele l√™ um √∫nico arquivo de texto contendo o c√≥digo-fonte de m√∫ltiplos arquivos e os distribui na estrutura de diret√≥rios correta, al√©m de, opcionalmente, fazer o commit das altera√ß√µes no Git.

Este projeto nasceu para acelerar o desenvolvimento iterativo, especialmente ao colaborar com Large Language Models (LLMs). √â uma ferramenta da **Dom Tech Solutions**.

## Funcionalidades

* Cria automaticamente a estrutura de diret√≥rios em um diret√≥rio de destino especificado.
* Distribui o c√≥digo-fonte para os arquivos corretos a partir de um √∫nico arquivo de origem.
* **Adiciona um carimbo de data/hora** em cada arquivo modificado para controle de vers√£o.
* **Protege arquivos sens√≠veis** e de configura√ß√£o (como `.env` e `PROMPT_TEMPLATE.md`) de serem sobrescritos.
* Opcionalmente, faz o `git commit` das altera√ß√µes no reposit√≥rio de destino com uma mensagem extra√≠da do pr√≥prio arquivo de origem.

## Instala√ß√£o e Uso

1.  **Clone o reposit√≥rio do DomTech Forger:**
    ```sh
    git clone [https://github.com/DomTechSolutions/domtech-forger.git](https://github.com/DomTechSolutions/domtech-forger.git)
    ```

2.  **Crie um arquivo de atualiza√ß√£o** (ex: `politicamente_update.txt`) em qualquer lugar, seguindo o formato especificado em `PROMPT_TEMPLATE.md`.

3.  **Execute o script:**
    Execute o script `DomTech Forger`, especificando o caminho para o arquivo de atualiza√ß√£o e o diret√≥rio do seu projeto alvo.

    * **Para atualizar e fazer o commit (padr√£o):**
        ```sh
        python /caminho/para/domtech-forger/src/domtech_forger/main.py /caminho/para/politicamente_update.txt --destination /caminho/para/seu/projeto/alvo
        ```

    * **Se voc√™ estiver dentro da pasta do projeto alvo, pode simplificar:**
        ```sh
        python /caminho/para/domtech-forger/src/domtech_forger/main.py /caminho/para/politicamente_update.txt --destination .
        ```

    * **Para apenas atualizar os arquivos, sem fazer o commit:**
        ```sh
        python /caminho/para/domtech-forger/src/domtech_forger/main.py /caminho/para/politicamente_update.txt --destination . --commit=false
        ```
    *Obs: Uma forma mais avan√ßada seria adicionar a pasta do `domtech-forger` ao seu `PATH` do sistema para poder cham√°-lo de qualquer lugar.*

## Licen√ßa

Este projeto √© licenciado sob a Licen√ßa MIT. Veja o arquivo `LICENSE` para mais detalhes.

---
## Arquivo: src/domtech_forger/__init__.py

# Este arquivo pode ficar vazio. Ele serve para que o Python trate o diret√≥rio 'domtech_forger' como um pacote.

---
## Arquivo: src/domtech_forger/main.py

import os
import re
import subprocess
import argparse
from datetime import datetime

# --- CONFIGURA√á√ÉO ---
FILE_HEADER_PATTERN = re.compile(r'## Arquivo: (.*?)\n')
COMMIT_HEADER_PATTERN = re.compile(r'## Mensagem de Commit:\n')
# Lista de arquivos e diret√≥rios que n√£o devem ser sobrescritos se j√° existirem.
PROTECTED_PATHS = ['.env', 'PROMPT_TEMPLATE.md']

def get_watermark(is_special_case=False):
    """Gera um carimbo de data/hora."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    if is_special_case:
        # Formato para arquivos sem extens√£o como LICENSE
        return f"\n\n# --- \n# Arquivo atualizado pelo DomTech Forger em {timestamp}\n"
    return f"# Este arquivo foi gerado/atualizado pelo DomTech Forger em {timestamp}\n\n"

def get_markdown_watermark():
    """Gera um carimbo de data/hora espec√≠fico para Markdown."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    return f"<!-- Este arquivo foi gerado/atualizado pelo DomTech Forger em {timestamp} -->\n\n"


def run_git_command(command, target_dir):
    """Executa um comando git dentro de um diret√≥rio alvo."""
    try:
        subprocess.run(command, check=True, capture_output=True, text=True, encoding='utf-8', cwd=target_dir)
        return True
    except subprocess.CalledProcessError as e:
        print(f"‚ùå Erro ao executar o comando git: {' '.join(command)} em '{target_dir}'")
        print(f"   Sa√≠da de erro: {e.stderr}")
        return False
    except FileNotFoundError:
        print("‚ùå Erro: O comando 'git' n√£o foi encontrado. Verifique se o Git est√° instalado e no seu PATH.")
        return False

def apply_updates(source_file, destination_dir, perform_commit):
    """
    L√™ o arquivo de c√≥digo-fonte consolidado, distribui o conte√∫do
    e, opcionalmente, faz o commit das altera√ß√µes no diret√≥rio de destino.
    """
    print(f"‚öôÔ∏è  Iniciando atualiza√ß√£o do projeto em '{destination_dir}'...")
    print(f"   Usando o arquivo de origem: '{source_file}'")

    try:
        with open(source_file, 'r', encoding='utf-8') as f:
            content = f.read()
    except FileNotFoundError:
        print(f"‚ùå Erro: O arquivo de origem '{source_file}' n√£o foi encontrado.")
        print("Por favor, verifique o caminho e tente novamente.")
        return

    blocks = content.split('\n---\n')
    files_created_or_updated = 0
    commit_message = None

    for block in blocks:
        if not block.strip():
            continue

        file_match = FILE_HEADER_PATTERN.search(block)
        commit_match = COMMIT_HEADER_PATTERN.search(block)

        if file_match:
            relative_path = file_match.group(1).strip()
            full_path = os.path.join(destination_dir, relative_path)
            code_content = block[file_match.end():].strip()

            if relative_path in PROTECTED_PATHS:
                if os.path.exists(full_path):
                    print(f"‚ö†Ô∏è  Arquivo protegido '{full_path}' j√° existe. Pulando para manter a vers√£o local.")
                    continue
                else:
                    print(f"‚ú®  Criando arquivo de exemplo para '{full_path}'.")

            try:
                directory = os.path.dirname(full_path)
                if directory:
                    os.makedirs(directory, exist_ok=True)

                # L√≥gica do Carimbo de Data/Hora
                _, file_extension = os.path.splitext(relative_path)

                if file_extension == '.md':
                    watermark = get_markdown_watermark()
                    final_content = watermark + code_content
                elif not file_extension: # Caso especial para arquivos como LICENSE
                    watermark = get_watermark(is_special_case=True)
                    final_content = code_content + watermark
                else: # Padr√£o para .py, .gitignore, etc.
                    watermark = get_watermark()
                    final_content = watermark + code_content

                with open(full_path, 'w', encoding='utf-8') as f:
                    f.write(final_content)

                print(f"‚úîÔ∏è Arquivo '{full_path}' criado/atualizado com sucesso.")
                files_created_or_updated += 1
            except IOError as e:
                print(f"‚ùå Erro ao escrever o arquivo '{full_path}': {e}")

        elif commit_match:
            commit_message = block[commit_match.end():].strip()
            print("‚úîÔ∏è Mensagem de commit encontrada.")

    print(f"\nüéâ Processo de arquivos conclu√≠do! {files_created_or_updated} arquivos foram atualizados.")

    if perform_commit and commit_message:
        print(f"\nüöÄ Iniciando processo de versionamento em '{destination_dir}'...")
        print("   Adicionando todos os arquivos ao stage...")
        if run_git_command(['git', 'add', '.'], destination_dir):
            print(f"   Fazendo commit com a mensagem:\n---IN√çCIO---\n{commit_message}\n---FIM---")
            if run_git_command(['git', 'commit', '-m', commit_message], destination_dir):
                print("‚úÖ Commit realizado com sucesso!")
    elif perform_commit and not commit_message:
        print("\n‚ö†Ô∏è O commit foi solicitado, mas nenhuma mensagem de commit foi encontrada no arquivo de origem.")
    else:
        print("\n‚ÑπÔ∏è  O commit autom√°tico n√£o foi solicitado. Processo finalizado.")

def main():
    """Fun√ß√£o principal para analisar os argumentos e iniciar o script."""
    parser = argparse.ArgumentParser(description="Atualiza arquivos de um projeto alvo a partir de um arquivo de origem e opcionalmente faz o commit.")

    parser.add_argument(
        'source_file',
        type=str,
        help="Caminho para o arquivo de texto com as atualiza√ß√µes."
    )

    parser.add_argument(
        '--destination',
        type=str,
        default='.',
        help="Caminho para o diret√≥rio do projeto alvo. Padr√£o: diret√≥rio atual."
    )

    parser.add_argument(
        '--commit',
        type=str,
        choices=['true', 'false'],
        default='true',
        help="Define se o script deve fazer o commit das altera√ß√µes. Padr√£o: true"
    )

    args = parser.parse_args()

    apply_updates(
        source_file=args.source_file,
        destination_dir=args.destination,
        perform_commit=(args.commit == 'true')
    )

if __name__ == "__main__":
    main()

---
## Mensagem de Commit:

refactor(forger): aprimora l√≥gica de carimbo de data/hora

Refatora a fun√ß√£o `get_watermark` e a l√≥gica de aplica√ß√£o para lidar com casos especiais, como arquivos sem extens√£o (ex: LICENSE).

- O carimbo de data/hora para arquivos sem extens√£o agora √© adicionado ao final do arquivo para n√£o interferir com o conte√∫do principal.
- O c√≥digo foi ajustado para ser mais limpo e tratar diferentes tipos de arquivos de forma mais expl√≠cita.
