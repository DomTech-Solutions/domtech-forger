# PROJETO: domtech-forger/

A estrutura de pastas profissional para a sua ferramenta.

domtech-forger/
├── .gitignore
├── LICENSE
├── PROMPT_TEMPLATE.md
├── README.md
└── src/
    └── domtech_forger/
        ├── __init__.py
        └── main.py


A seguir, o conteúdo completo de cada arquivo.

---
## Arquivo: .gitignore

# Ambientes virtuais
venv/
.venv/
env/

# Arquivos de cache do Python
__pycache__/
*.pyc

# Arquivos de IDE
.vscode/
.idea/

# Arquivos de dependências e build
dist/
build/
*.egg-info/

---
## Arquivo: LICENSE

MIT License

Copyright (c) 2025 Dom Tech Solutions

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

---
## Arquivo: PROMPT_TEMPLATE.md

# Prompt Template para Geração de Código Compatível com o DomTech Forger

Use o seguinte template ao instruir um Large Language Model (LLM) para gerar o código-fonte de um projeto completo em um único bloco de texto. Isso garantirá que a saída seja compatível com a ferramenta de automação `DomTech Forger`.

## Template do Prompt

"Por favor, gere a estrutura completa de arquivos para o projeto [NOME DO PROJETO]. A saída deve ser um único bloco de código. Cada arquivo deve ser precedido por um cabeçalho no formato `## Arquivo: caminho/completo/do/arquivo.ext` e o conteúdo de cada arquivo deve ser separado por uma linha contendo apenas `---`.

Se houver uma mensagem de commit sugerida, ela deve estar em seu próprio bloco, precedida por `## Mensagem de Commit:` e separada por `---`.

**Exemplo de Estrutura:**

```
## Arquivo: src/main.py

print("Olá, Mundo!")

---
(separador)
---

## Arquivo: README.md

# Meu Projeto

Este é um projeto de exemplo.

---
(separador)
---

## Mensagem de Commit:

feat: cria estrutura inicial do projeto

Adiciona os arquivos `main.py` e `README.md` para a configuração inicial do projeto.
```"
---
## Arquivo: README.md

# DomTech Forger

**DomTech Forger** é uma ferramenta de linha de comando em Python projetada para automatizar a criação e atualização de projetos de software. Ele lê um único arquivo de texto contendo o código-fonte de múltiplos arquivos e os distribui na estrutura de diretórios correta, além de, opcionalmente, fazer o commit das alterações no Git.

Este projeto nasceu para acelerar o desenvolvimento iterativo, especialmente ao colaborar com Large Language Models (LLMs). É uma ferramenta da **Dom Tech Solutions**.

## Funcionalidades

* Cria automaticamente a estrutura de diretórios em um diretório de destino especificado.
* Distribui o código-fonte para os arquivos corretos a partir de um único arquivo de origem.
* **Adiciona um carimbo de data/hora** em cada arquivo modificado para controle de versão.
* **Protege arquivos sensíveis** e de configuração (como `.env` e `PROMPT_TEMPLATE.md`) de serem sobrescritos.
* Opcionalmente, faz o `git commit` das alterações no repositório de destino com uma mensagem extraída do próprio arquivo de origem.

## Instalação e Uso

1.  **Clone o repositório do DomTech Forger:**
    ```sh
    git clone [https://github.com/DomTechSolutions/domtech-forger.git](https://github.com/DomTechSolutions/domtech-forger.git)
    ```

2.  **Crie um arquivo de atualização** (ex: `politicamente_update.txt`) em qualquer lugar, seguindo o formato especificado em `PROMPT_TEMPLATE.md`.

3.  **Execute o script:**
    Execute o script `DomTech Forger`, especificando o caminho para o arquivo de atualização e o diretório do seu projeto alvo.

    * **Para atualizar e fazer o commit (padrão):**
        ```sh
        python /caminho/para/domtech-forger/src/domtech_forger/main.py /caminho/para/politicamente_update.txt --destination /caminho/para/seu/projeto/alvo
        ```

    * **Se você estiver dentro da pasta do projeto alvo, pode simplificar:**
        ```sh
        python /caminho/para/domtech-forger/src/domtech_forger/main.py /caminho/para/politicamente_update.txt --destination .
        ```

    * **Para apenas atualizar os arquivos, sem fazer o commit:**
        ```sh
        python /caminho/para/domtech-forger/src/domtech_forger/main.py /caminho/para/politicamente_update.txt --destination . --commit=false
        ```
    *Obs: Uma forma mais avançada seria adicionar a pasta do `domtech-forger` ao seu `PATH` do sistema para poder chamá-lo de qualquer lugar.*

## Licença

Este projeto é licenciado sob a Licença MIT. Veja o arquivo `LICENSE` para mais detalhes.

---
## Arquivo: src/domtech_forger/__init__.py

# Este arquivo pode ficar vazio. Ele serve para que o Python trate o diretório 'domtech_forger' como um pacote.

---
## Arquivo: src/domtech_forger/main.py

import os
import re
import subprocess
import argparse
from datetime import datetime

# --- CONFIGURAÇÃO ---
FILE_HEADER_PATTERN = re.compile(r'## Arquivo: (.*?)\n')
COMMIT_HEADER_PATTERN = re.compile(r'## Mensagem de Commit:\n')
# Lista de arquivos e diretórios que não devem ser sobrescritos se já existirem.
PROTECTED_PATHS = ['.env', 'PROMPT_TEMPLATE.md']

def get_watermark(is_special_case=False):
    """Gera um carimbo de data/hora."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    if is_special_case:
        # Formato para arquivos sem extensão como LICENSE
        return f"\n\n# --- \n# Arquivo atualizado pelo DomTech Forger em {timestamp}\n"
    return f"# Este arquivo foi gerado/atualizado pelo DomTech Forger em {timestamp}\n\n"

def get_markdown_watermark():
    """Gera um carimbo de data/hora específico para Markdown."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    return f"<!-- Este arquivo foi gerado/atualizado pelo DomTech Forger em {timestamp} -->\n\n"


def run_git_command(command, target_dir):
    """Executa um comando git dentro de um diretório alvo."""
    try:
        subprocess.run(command, check=True, capture_output=True, text=True, encoding='utf-8', cwd=target_dir)
        return True
    except subprocess.CalledProcessError as e:
        print(f"❌ Erro ao executar o comando git: {' '.join(command)} em '{target_dir}'")
        print(f"   Saída de erro: {e.stderr}")
        return False
    except FileNotFoundError:
        print("❌ Erro: O comando 'git' não foi encontrado. Verifique se o Git está instalado e no seu PATH.")
        return False

def apply_updates(source_file, destination_dir, perform_commit):
    """
    Lê o arquivo de código-fonte consolidado, distribui o conteúdo
    e, opcionalmente, faz o commit das alterações no diretório de destino.
    """
    print(f"⚙️  Iniciando atualização do projeto em '{destination_dir}'...")
    print(f"   Usando o arquivo de origem: '{source_file}'")

    try:
        with open(source_file, 'r', encoding='utf-8') as f:
            content = f.read()
    except FileNotFoundError:
        print(f"❌ Erro: O arquivo de origem '{source_file}' não foi encontrado.")
        print("Por favor, verifique o caminho e tente novamente.")
        return

    blocks = content.split('\n---\n')
    files_created_or_updated = 0
    commit_message = None

    for block in blocks:
        if not block.strip():
            continue

        file_match = FILE_HEADER_PATTERN.search(block)
        commit_match = COMMIT_HEADER_PATTERN.search(block)

        if file_match:
            relative_path = file_match.group(1).strip()
            full_path = os.path.join(destination_dir, relative_path)
            code_content = block[file_match.end():].strip()

            if relative_path in PROTECTED_PATHS:
                if os.path.exists(full_path):
                    print(f"⚠️  Arquivo protegido '{full_path}' já existe. Pulando para manter a versão local.")
                    continue
                else:
                    print(f"✨  Criando arquivo de exemplo para '{full_path}'.")

            try:
                directory = os.path.dirname(full_path)
                if directory:
                    os.makedirs(directory, exist_ok=True)

                # Lógica do Carimbo de Data/Hora
                _, file_extension = os.path.splitext(relative_path)

                if file_extension == '.md':
                    watermark = get_markdown_watermark()
                    final_content = watermark + code_content
                elif not file_extension: # Caso especial para arquivos como LICENSE
                    watermark = get_watermark(is_special_case=True)
                    final_content = code_content + watermark
                else: # Padrão para .py, .gitignore, etc.
                    watermark = get_watermark()
                    final_content = watermark + code_content

                with open(full_path, 'w', encoding='utf-8') as f:
                    f.write(final_content)

                print(f"✔️ Arquivo '{full_path}' criado/atualizado com sucesso.")
                files_created_or_updated += 1
            except IOError as e:
                print(f"❌ Erro ao escrever o arquivo '{full_path}': {e}")

        elif commit_match:
            commit_message = block[commit_match.end():].strip()
            print("✔️ Mensagem de commit encontrada.")

    print(f"\n🎉 Processo de arquivos concluído! {files_created_or_updated} arquivos foram atualizados.")

    if perform_commit and commit_message:
        print(f"\n🚀 Iniciando processo de versionamento em '{destination_dir}'...")
        print("   Adicionando todos os arquivos ao stage...")
        if run_git_command(['git', 'add', '.'], destination_dir):
            print(f"   Fazendo commit com a mensagem:\n---INÍCIO---\n{commit_message}\n---FIM---")
            if run_git_command(['git', 'commit', '-m', commit_message], destination_dir):
                print("✅ Commit realizado com sucesso!")
    elif perform_commit and not commit_message:
        print("\n⚠️ O commit foi solicitado, mas nenhuma mensagem de commit foi encontrada no arquivo de origem.")
    else:
        print("\nℹ️  O commit automático não foi solicitado. Processo finalizado.")

def main():
    """Função principal para analisar os argumentos e iniciar o script."""
    parser = argparse.ArgumentParser(description="Atualiza arquivos de um projeto alvo a partir de um arquivo de origem e opcionalmente faz o commit.")

    parser.add_argument(
        'source_file',
        type=str,
        help="Caminho para o arquivo de texto com as atualizações."
    )

    parser.add_argument(
        '--destination',
        type=str,
        default='.',
        help="Caminho para o diretório do projeto alvo. Padrão: diretório atual."
    )

    parser.add_argument(
        '--commit',
        type=str,
        choices=['true', 'false'],
        default='true',
        help="Define se o script deve fazer o commit das alterações. Padrão: true"
    )

    args = parser.parse_args()

    apply_updates(
        source_file=args.source_file,
        destination_dir=args.destination,
        perform_commit=(args.commit == 'true')
    )

if __name__ == "__main__":
    main()

---
## Mensagem de Commit:

refactor(forger): aprimora lógica de carimbo de data/hora

Refatora a função `get_watermark` e a lógica de aplicação para lidar com casos especiais, como arquivos sem extensão (ex: LICENSE).

- O carimbo de data/hora para arquivos sem extensão agora é adicionado ao final do arquivo para não interferir com o conteúdo principal.
- O código foi ajustado para ser mais limpo e tratar diferentes tipos de arquivos de forma mais explícita.
